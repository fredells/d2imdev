\chapter{游戏脚本系统}
为什么游戏需要脚本系统？因为脚本是游戏剧情扩展的有效手段。脚本系统，地图编辑器，资源管理器，是一款良好的游戏作品中的必要环节。

D2S的语法和在游戏中的运行模型耗费了我很多心思。我开始想要使用单线程模型，每个游戏轮转执行一个命令。这会导致某个命令执行时间特别长导致游戏卡住的问题。我想支持start/end实现单步/并行混合脚本，这使得在并行时候调用子脚本出现困难。我想使用多线程模型，又存在一个线程间脚本命令冲突的问题。比如让一个Player走到NPC身边，然后和NPC对话。如果使用多线程模型，一个脚本控制Player走到NPC身边，等待这个任务结束后再和NPC对话，然而如果此时另外一个脚本使得Player自杀。这时候第一个脚本的等待状态就会一直持续下去，不得结束。这明显是错误的。

我想这是个很费脑筋的环节，我是不是该减弱脚本的功能？
对，我决定减弱脚本系统的功能，任何脚本命令都是单步的，非单步命令将被集成为特殊命令。彻底的摒弃单步和非单步混合编程模式。

下面是一个关于这个问题的经典论述：

如今有一些不同类型的脚本系统可供程序员或者美术师使用，而且它用非常有条理和逻辑的思想恰当地做这些。第一种是简单的基于文本的，单线索的风格，就像我们程序员习惯的编码。在许多情况，它实际上基於 C，尽管以一种非常简单的形式。 大量这种类似“if this，then do that”的东西。大部分脚本倾向在范围内是相当线性的—意味着它通常由许多在次序上彼此相接的命令组成。在世界中移动角色A指向B。当完成以后，让他讲话，完成以后，移动他指向C。相当简单的事情。

　　然后有复杂的东西--允许多重线索，和实际上允许可变情形。可变情形是当脚本开始时你实际上不能确知谁会出现在附近，但是你必须按这样的方式编写脚本以便任何人出现在附近它都将会工作。举例来说--一个正常的简单脚本会有三个家伙，全部被预先定义，全部有一组他们将会讨论的情形。一个可变的脚本将会有三个人,你不能保证是某一个特定的人，并必须按相同的方式工作。或者在一个极端的情形中，也许只有二个，或者甚至一个家伙将会在那里，使得三方交谈有一点困难。

　　Raven在Star Trek Voyager: Elite Force中面临的一个很大的问题是这样的情形，使用者可能会想要把一个角色从一条船的某个地方带到另外一个地方，但是从A点到B点的路径可能会随着每次游戏根本地改变。举例来说，他们需要让Munro(你所扮演的游戏主要角色)从发动机舱室到输送舱。 不幸的是由于游戏的非直线性，在事件到达这一点以前你可能已经破坏了涡轮升降机，或者也许 Jeffries 管被损害不能通过。假定当脚本开始的时候我们不知道世界的状态，我们不得不为几乎各种可能发生的事情编写脚本以便适用于这些‘如果。。。怎么办’的情形。而且它仅仅从那里变得更加糟糕。我们能建立的一些情形提供了如此多可能的组合情形，以致于为了一个满意的结论而准确测试每一个可能发生的事情几乎是不可能的。请和在SiN, Star Trek Voyager : Elite Force or Deus Ex中工作的任何人谈谈。QA部门传统地憎恨这些类型游戏，因为这已经使他们的工作比以前更加困难了 50 倍。

　　你能够想象为这些情形编写脚本是何等的困难。但那是今天的非线性游戏路径要求的事情，而且它为何博得了较多的开发支持从而能够努力实现它。

\newpage

\section{D2S系统的思考}

任何一个指令都能被分割成多周期执行。

\begin{lstlisting}
/*
**  args    : 输入参数数组
**  ret     : < 0 指令执行出错
**            = 0 指令执行完成
**            > 0 指令执行尚未完成
**
**  指令出错码  -1  : 找不到命令
**              -2  : 指令参数格式不对
*/
int do_cmd(char *args)
\end{lstlisting}

例如，在如下的脚本系统中，假设cmd1为即时命令，cmd2为过程命令。
\begin{lstlisting}
while eva $(cmd1 -op) > $(calc $(cmd2 -op) - 2)
    cmd3 -op
    cmd4 -op
end
\end{lstlisting}
d2s引擎首先获得第一行文本，存入内部cmd\_buf，扫描发现\$(符号，于是取出\$()中的“cmd1 -op”，并调用
\begin{lstlisting}
    ret = do_cmd("cmd1 -op");
\end{lstlisting}
返回ret为0，表示已经执行完毕，于是继续扫描

规定\$(cmd)可以嵌套和递归。
嵌套如：
\begin{lstlisting}
    cmd -op $(cmd1 $(cmd2))
\end{lstlisting}
递归的情况如下，假设有一个脚本为cmd，内容如下：
\begin{lstlisting}
# cmd脚本
# 脚本在参数为小于10时候返回命令本身
# 并将返回值置为1
if eva $1 < 10
    echo '$(cmd' $(calc $1 + 1))
    exit 1
end
\end{lstlisting}
下面这句while命令调用它：
\begin{lstlisting}
    while $(cmd 1)
    end
\end{lstlisting}

D2S解释器首先扫描第一行，发现\$()，于是调用函数：
\begin{lstlisting}
    ret = do_cmd("cmd 1");
\end{lstlisting}
首先返回ret为0，表示执行完毕，输出为"\$(cmd 2)"，于是继续进行。

还有一种就是一般意义的递归：
\begin{lstlisting}
# cmd脚本
# 脚本在参数为小于10时候返回命令本身
# 并将返回值置为1
if eva $1 < 10
    echo $(cmd $(calc $1 + 1))
    exit 1
end
\end{lstlisting}

当执行到echo这一行的时候，首先发现\$(cmd，于是继续扫描参数，发现参数也是\$(继续扫描。
恩，一般执行顺序为：

先得到一行，扫描发现第一个\$(后，寻找匹配的)，如果在寻找过程中发现第二个\$(就先找第二个的，再找第一个的。为深度优先搜索的解释顺序。实现的时候用树来解决。









默认一个任务有一个动作。
\section{脚本系统基本要求}
任何一个脚本系统都需要有注释语句，变量操作以及流程控制语句。D2S也不例外。
\section{D2S脚本解析系统}
D2S脚本系统是大小写敏感的。

\subsection{注释语句}
D2S使用井号（\#）表示一行的注释，注意D2S只有这一种注释方式。如果在语句中需要使用\#，应该使用\\\#。D2S的注释规则和Linux下Bash规则接近。

\begin{lstlisting}

NAME@D2IM$ echo "The # here does not begin a comment."
NAME@D2IM$ echo 'The # here does not begin a comment.'
NAME@D2IM$ echo The \# here does not begin a comment.
\end{lstlisting}

\subsection{变量及其赋值}
D2S的变量命名的格式用正则表达式如下：
\begin{lstlisting}
[_a-zA-Z]\+[_a-zA-Z0-9]*
\end{lstlisting}
变量的赋值需要使用到内嵌的let命令：
\begin{lstlisting}
let var1 = 12               # 整数值
let var2 = 1.2              # 浮点数值
let var3 = hello world      # 字符串
let cmd  = "cmd1 or cmd2"   # 命令
let cmd  = cmd1  or cmd     # 两条命令
let var = ${eval ($var1+$var2)/23.1 - 12.4}
\end{lstlisting}
变量值的引用使用\$(var)进行，注意()是可以省略的，省略括号的原则是不应引起混淆。建议始终使用\$()形式。
变量的清除使用unlet关键字：
\begin{lstlisting}
unlet var
\end{lstlisting}

\section{数组}
D2S中并不需要数组，因为我们总可以用如下方式引用值：

\begin{lstlisting}
for n in ${seq 1 100}
    let arr$n = $n
end

let ptr = arr
let cnt = 1
while [ -ne $cnt 100 ]
    echo $ptr$cnt
    let cnt++
end
\end{lstlisting}
\section{命令分割和组合}
如果多个命令需要放在一行，可以使用\&\&操作符予以分割。举例：
\begin{lstlisting}
cmd1 args && cmd2 args && cmd3 args
\end{lstlisting}
D2S解析时候会把\&\&前后视为两条不同的命令，如果不使用分隔符，第一个单词后面所有的单词都将视为第一个单词的参数。
\&\&操作符最主要的作用是和()操作符配合。小括号将多个命令合并为一个命令，括号内的所有命令将一起执行。
\begin{lstlisting}
(cmd1 args && cmd2 args && cmd3 args)
\end{lstlisting}
\section{命令组合}
使用()将多个命令组合为一个命令，命令之间使用and，or，not，xor分割。单步执行时括号内内容将作为一个整体一次执行。
\section{单步和并行}
游戏脚本区别于普通脚本最重要的地方就是脚本解析需要在单步方式和并行方式之间不断切换。举个例子：如果有NPC1和NPC2，当他们发现有玩家进入视野范围，需要主动走到玩家跟前并开始对话。我们使用游戏内部支持的goto语句：
\begin{lstlisting}
goto $(npc1) ${pos $player}
goto $(npc2) ${pos $player}
\end{lstlisting}
这样就会导致NPC1先走到player附近的位置，然后NPC2再走到player附近的位置。显然我们需要的是两个NPC“走”的动作同步进行。
再举个例子：在一个场景开始时候一般会有淡入，我们使用如下方式：
\begin{lstlisting}
ldmp  entry.map
playm background.mp3
fadin 1000
\end{lstlisting}
这时候我们便需要单步运行，同步运行只会导致游戏脚本出现bug。为了解决这一问题，D2M使用了关键字start，start启动一个复合命令并返回对应的描述符。例如：

\begin{lstlisting}

NAME@D2IM:~$ start sleep 1000
12
NAME@D2IM:~$ start (sleep 1000 && echo first)
15
first
NAME@D2IM:~$ start (sleep 1000 && echo first) && echo second
27
second
first
NAME@D2IM:~$

\end{lstlisting}

如果我们需要有规律并行命令，比如命令所有的monster开始进攻，我们可以这样：

\begin{lstlisting}

unlet pids
for monster in ${monsterid}
    let pids = $(pids) ${start attack $(monster)}
end
wait $(pids)

\end{lstlisting}

如果我们需要大块无规律的并行命令，我们可以：
\begin{lstlisting}
unlet pids
let pids = $(pids) ${start cmd1}
let pids = $(pids) ${start cmd2}
let pids = $(pids) ${start cmd3}
let pids = $(pids) ${start cmd4}
let pids = $(pids) ${start cmd5}
wait $(pids)
\end{lstlisting}
但这样较为繁琐，我们提供另一种更简洁的形式：
\begin{lstlisting}
start
    cmd1
    cmd2
    cmd3
wait
\end{lstlisting}
注意start和wait命令必须成对出现，并且不支持嵌套。一个start出现后，必须在对应的wait出现后才能重新出现start。
如果在start和wait之间出现脚本调用，例如上面的例子中cmd2不是一个内置命令而是一个脚本，那么在cmd2脚本中允许出现start和wait。运行时如果出现脚本调用，调用时自动将环境设置为单步模式，直到脚本调用返回，再将环境设置为原来的模式。
始终
\section{脚本调用}
D2S不支持函数，对应的D2S使用脚本调用来完成类似功能。在D2S中脚本调用和内置命令同级，脚本解析时不予区分。如果脚本和内置命令重名，D2S将优先使用脚本。因此你可以如此重定义内置命令。当然这会带来效率的些许降低。
脚本搜索路径由全局变量\$PATH决定。\$PATH的初始值在/bin/init中设置如下：
\begin{lstlisting}
let PATH = /bin:/sbin
export PATH
\end{lstlisting}
你也可以设置自己的PATH路径：
\begin{lstlisting}
let PATH = your\_dir:$PATH
export PATH
\end{lstlisting}
\subsection{IF语句}
IF语句共有如下三种基本形式：
\begin{lstlisting}
if condition
    commands
end

if condition
    commands
else
    commands
end

if condition
    commands
elif condition
    commands
elif condition
    commands
end
\end{lstlisting}
condition为一个判断状态，在脚本中可以用\$?获得其取值。在脚本系统中我们常用exit命令设定\$?取值。IF语句将获取\$?寄存器的值并以此作为判断依据。

\subsection{WHILE语句}
\begin{lstlisting}
while condition
    commands
end
\end{lstlisting}

\section{逻辑运算}
逻辑运算有四个，分别是and，or，not，xor。
\begin{lstlisting}
if cond1 and cond2
    commands
end

if cond1 or cond2
    commands
end

command or command2

commands1 and command2
\end{lstlisting}


\section{多选择分支}
switch支持正则匹配，格式如下：
\begin{lstlisting}
switch expr
    case pattern1:
        commands
    case pattern2:
        commands
    default:
        commands
end
\end{lstlisting}
注意switch和case之后的expr和pattern都从第一个非空白字符开始，如果expr或者pattern第一个字符为空格，应该使用\\s转义，或者用""将其转化为字符串，转化规则和前面相同。

D2S的解析逻辑如下：
获取一行
扫描变量描述符，如果有，对对应变量进行求值（求值是递归的），然后替换代入。由于是宏的作用，故任何内容皆可以代入，包括关键字。


D2M中语句的最小构成单位是词，词是以空白字符分割而成的，空白字符包括制表符和空格。例如：
goto $(player) $(x) $(y)
就是四个词。分别是goto、$(player)、$(x)和$(y)，这个语句将使得player步行到($x，$y)附近位置。

D2M暂时不支持输入输出重定向操作和管道，这是为了实现更加简单。如果我们需要将输出定向到文件或者用上一个命令的输出作为下一个命令的输入，我们可以使用如下形式：
\begin{lstlisting}
fprint /tmp/test ${cmd}
\end{lstlisting}
我承认这不简洁，但是确实实现起来简单多了！

简单命令的第一个词是要执行的命令，其余的词都是这个命令的参数，例如： 
echo "hello world" echo 
第一个echo 是命令，第二个词"hello world"是参数1，第三个词echo是参数2，而不再作为一个命令了。

D2S不支持管道，如果我们需要某个命令的输出，我们同样可以使用变量作中间媒介。



\begin{lstlisting}
用类似伪代码的形式表示如下： 
while(1) { 
print_prompt(); 
get_input(); 
parse_input(); 
if(“logout” || “exit”) 
break; 
do_cmd(); 
} 
读取用户输入 
如何获取用户输入？一种方法是通过 getchar() 从标准输入每次读一个字符，如果读到的字符是 ‘\n’，说明用户键入了回车键，那么就把此前读到的字符串作为用户输入的命令。 
代码如下： 
int len = 0; 
int ch; 
char buf[300]; 
ch = getchar(); 
while(len < BUFSIZ && ch != '\n') { 
buf[len++] = ch; 
ch = getchar(); 
} 
if(len == BUFSIZ) { 
printf("command is too long\n"); 
break; 
} 
buf[len] = '\n'; 
len++; 
buf[len] = 0; 
但是，我们注意到，在 bash 中，可以用“<-”和“->”键在命令行中左右移动，可以用上下键调用以前使用的命令，可以用退格键来删除一个字符，还可以用 tab 键来进行命令行补全。我们的shell如果也要支持这些功能，那么就必须对这些键进行处理。这样仅仅对用户输入的读取就非常麻烦了。 
实际上，任何需要一个获取用户输入的程序，都会涉及到同样的问题，如何象bash 那样处理键盘？GNU readline 库就是专门解决这个问题的，它把对键盘的操作完全封装起来，对外只提供一个简单的调用接口。有了它，对键盘的处理就不再让人头疼了。 
关于 readline 库的详细信息，可以通过 man readline 来看它的帮助页面。在我们的 shell 程序中，我是这样来使用 readline的。 
char* line; 
char prompt[200]; 
while(1) { 
set_prompt(prompt); 
if(!(line = readline(prompt))) 
break; 
。。。。。。 
} 
首先通过 set_prompt() 来设置要输出的提示符，然后以提示符作为参数调用 readline()，这个函数等待用户输入，并动态创建一块内存来保存用户输入的数据，可以通过返回的指针 line 得到这块内存。在每次处理完用户输入的命令之后，我们必须自己负责来释放这块内存。 
有了 readline 之后，我们就可以象 bash 那样使用键盘了。 
在通过 readline 获取用户输入之后，下一步就是对用户输入的命令进行分析。 
命令行分析 
对命令行的分析，实际上是一个词法分析过程。学过编译原理的朋友，都听说过 lex 和yacc 的大名，它们分别是词法分析和语法分析工具。Lex 和 yacc 都有GNU的版本（open source 的思想实在是太伟大了，什么好东东都有免费的用），分别是 flex 和 bison。 
所谓“工欲善其事，必先利其器”，既然有这么好的工具，那我们就不必辛辛苦苦自己进行词法分析了。对，我们要用 lex 来完成枯燥的命令行词法分析工作。 
“去买本《lex与yacc》（中国电力出版社）来看吧。第一次学当然稍微有点难度，不过一旦掌握了，以后再碰到类似问题，就可以多一个利器，可以节省劳动力了。 
在我们的这个 shell 程序中，用 flex 来完成词法分析工作。相对语法分析来说，词法分析要简单的多。由于我们只是做一个简单的 shell，因此并没有用到语法分析，而实际上在 bash 的实现代码中，就用到了语法分析和 yacc。 
关于 lex 的细节，在这里我就不能多说了。Lex程序，通常分为三个部分，其中进行语法分析工作的就是它的第二部分： “规则”。规则定义了在词法分析过程中，遇到什么样的情况，应该如何处理。 
词法分析的思路，就是根据前面定义的“shell语法规范”来把用户输入的命令行拆解成 
首先，我们要把用户输入的命令，以空白字符（tab键或者空格）分隔成一个个的参数，并把这些参数保存到一个参数数组中。但是，这其中有几种特殊情况。 
一、如果遇到的字符是“;”、“>”、“<”或“|”，由于这些符号是管道或者列表中所用到的分隔符，因此必须把它们当作一个单独的参数。 
二、以双引号（”）括起来的字符串要作为一个单独的参数，即使其中出现了空白字符、“;”、“>”、“<”、“|”。其实，在POSIX标准中，对引号的处理相当复杂，不仅包括双引号（”），还有单引号（’）、反引号（`），在什么情况下，应该用什么样的引号以及对引号中的字符串应该如何解释，都有一大堆的条款。我们这里只是处理一种极简单的情况。 
其次，如果我们遇到换行符（’\n’），那么就结束本次命令行分析。根据前面定义的 shell 语法规范，最上层的是列表命令，因此下一步是把所有的参数作为一个列表命令来处理。 
根据这个思路，我们来看对应的 lex 规则。 
%% 
"\"" {BEGIN QUOTE;} 
[^\n"]+ {add_arg(yytext);} 
"\"" {BEGIN 0;} 
\n {BEGIN 0; do_list_cmd(); reset_args();} 
";" {add_simple_arg(yytext);} 
">" {add_simple_arg(yytext);} 
"<" {add_simple_arg(yytext);} 
"|" {add_simple_arg(yytext);} 
[^ \t\n|<>;"]+ {add_arg(yytext);} 
\n {do_list_cmd(); reset_args();} 
. ; 
%% 
我们对这些规则逐条解释： 
1－4这4条规则，目的是为了在命令行中支持引号，它们用到了 lex 规则的状态特性。 
1、"\"" {BEGIN QUOTE;} 
2、[^\n"]+ {add_arg(yytext);} 
3、"\"" {BEGIN 0;} 
4、\n {BEGIN 0; do_list_cmd(); reset_args();} 
1、 如果扫描到引号（ “），那么进入 QUOTE 状态。在这个状态下，即使扫描到空白字符或“;”、“>”、“<”、“|”，也要当作普通的字符。 
2、 如果处于 QUOTE状态，扫描到除引号和回车以外的字符，那么调用 add_arg()函数，把整个字符串加入到参数数组中。 
3、 如果处于QUOTE状态，扫描到引号，那么表示匹配了前面的引号，于是恢复到默认状态。 
4、 如果处于QUOTE状态，扫描到回车，那么结束了本次扫描，恢复到默认状态，并执行 do_list_cmd()，来执行对列表命令的处理。 
以下几条规则，是在处于默认状态的情况下的处理。 
5、";" {add_simple_arg(yytext);} 
6、">" {add_simple_arg(yytext);} 
7、"<" {add_simple_arg(yytext);} 
8、"|" {add_simple_arg(yytext);} 
9、[^ \t\n|<>;"]+ {add_arg(yytext);} 
10、\n {do_list_cmd(); reset_args();} 
5、 如果遇到分号（;），因为这是一个列表命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
6、 如果遇到 >，因为这是一个简单命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
7、 如果遇到 <，因为这是一个简单命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
8、 如果遇到管道符号（|），因为这是一个管道命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
9、 对于不是制表符（tab）、换行符（’\n’）、| 、<、>和分号（;）以外的字符序列，作为一个普通的参数，加入参数数组。 
10、 如果遇到换行符，那么结束本次扫描，执行 do_list_cmd()，来执行对列表命令的处理。 
11、 对于任意其它字符，忽略 
通过 lex 的“规则”把用户输入的命令行分解成一个个的参数之后，都要执行 do_list_cmd() 来执行对列表命令的处理。 
命令处理 
首先是对处于“shell语法规范”中最上层的列表命令的处理。 
l 列表命令的处理过程： 
依次检查参数数组中的每一个参数，如果是分号（;），那么就认为分号前面的所有参数组成了一个管道命令，调用 do_pipe_cmd() 来执行对管道命令的处理。如果扫描到最后，不再有分号出现，那么把剩下的所有参数作为一个管道命令处理。 
代码很简单： 
static void do_list_cmd() 
{ 
int i = 0; 
int j = 0; 
char* p; 
while(argbuf[i]) { 
if(strcmp(argbuf[i], ";") == 0) {// ; 
p = argbuf[i]; 
argbuf[i] = 0; 
do_pipe_cmd(i-j, argbuf+j); 
argbuf[i] = p; 
j = ++i; 
} else 
i++; 
} 
do_pipe_cmd(i-j, argbuf+j); 
} 
接下来是对管道命令的处理。 
管道命令的处理 
管道是进程间通信（IPC）的一种形式，关于管道的详细解释在《unix高级环境编程》第14章：进程间通信以及《unix网络编程：第2卷：进程间通信》第4章：管道和FIFO中可以看到。 
我们还是来看一个管道的例子： 
[root@stevens root]# echo “hello world”|wc –c |wc –l 
在这个例子中，有三个简单命令和两个管道。 
第一个命令是 echo “hello world”，它在屏幕上输出 hello world。由于它后面是一个管道，因此，它并不在屏幕上输出结果，而是把它的输出重定向到管道的写入端。 
第二个命令是 wc –c，它本来需要指定输入源，由于它前面是一个管道，因此它就从这个管道的读出端读数据。也就是说读到的是 hello world，wc –c 是统计读到的字符数，结果应该是12。由于它后面又出现一个管道，因此这个结果不能输出到屏幕上，而是重定向到第二个管道的写入端。 
第三个命令是 wc –l。它同样从第二个管道的读出端读数据，读到的是12，然后它统计读到了几行数据，结果是1行，于是在屏幕上输出的最终结果是1。 
在这个例子中，第一个命令只有一个“后”管道，第三个命令只有一个“前”管道，而第二个命令既有“前”管道，又有“后”管道。 
在我们处理管道命令的do_pipe_cmd()函数中，它的处理过程是： 
首先定义两个管道 prefd 和 postfd，它们分别用来保存“前”管道和“后”管道。此外，还有一个变量 prepipe 来指示“前”管道是否有效。 
然后依次检查参数数组中每一个参数，如果是管道符号（|），那么就认为管道符号前面所有的参数组成了一个简单命令，并创建一个“后”管道。如果没有“前”管道（管道中第一个简单命令是没有“前”管道的），那么只传递“后”管道来调用do_simple_cmd()，否则，同时传递“前”管道和“后”管道来调用 do_simple_cmd()。 
执行完以后，用“前”管道来保存当前的“后”管道，并设置“前”管道有效标识prepipe，继续往后扫描。如果扫描到最后，不再有管道符号出现，那么只传递“前”管道来调用do_simple_cmd()。 
代码如下： 
int i = 0, j = 0, prepipe = 0; 
int prefd[2], postfd[2]; 
char* p; 
while(argv[i]) { 
if(strcmp(argv[i], "|") == 0) { // pipe 
p = argv[i]; 
argv[i] = 0; 
pipe(postfd); //create the post pipe 
if(prepipe) 
do_simple_cmd(i-j, argv+j, prefd, postfd); 
else 
do_simple_cmd(i-j, argv+j, 0, postfd); 
argv[i] = p; 
prepipe = 1; 
prefd[0] = postfd[0]; 
prefd[1] = postfd[1]; 
j = ++i; 
} else 
i++; 
} 
if(prepipe) 
do_simple_cmd(i-j, argv+j, prefd, 0); 
else 
do_simple_cmd(i-j, argv+j, 0, 0); 
最后，我们分析简单命令的处理过程。 
简单命令处理过程 
我们已经看到，对列表命令和管道命令的处理，实际只是一个分解过程，最终命令的执行还是要由简单命令来完成。 
在简单命令的处理过程中，必须考虑以下情况： 
1、区分内部命令和外部命令 
根据简单命令的定义，它的第一个参数是要执行的命令，后面的参数作为该命令的参数。要执行的命令有两种情况： 
一种是外部命令，也就是对应着磁盘上的某个程序，例如 wc、ls等等。对这种外部命令，我们首先要到指定的路径下找到它，然后再执行它。 
二是内部命令，内部命令并不对应磁盘上的程序，例如cd、echo等等，它需要shell自己来决定该如何执行。例如对 cd 命令，shell就应该根据它后面的参数改变当前路径。 
对于外部命令，需要创建一个子进程来执行它，而对于内部命令，则没有这个必要。 
外部命令的执行，是通过 exec 函数来完成的。有六种不同形式的 exec 函数，它们可以统称为 exec 函数。我们使用的是 execv()。关于 exec的细节，请看《unix环境高级编程》第8章：进程控制。 
对于内部命令，我们目前支持五种，分别是： 
exit：退出shell解释器 
cd：改变目录 
echo：回显 
export：导入或显示环境变量 
history：显示命令历史信息 
这几个内部命令分别由 do_exit()、do_cd()、do_echo()、do_export()、do_history()来实现。 
2、处理重定向 
在简单命令的定义中，包括了对重定向的支持。重定向有多种情况，最简单的是输入重定向和输出重定向，分别对应着“<”和“>”。 
输入重定向，就是把“<”后面指定的文件作为标准输入，例如： 
wc < xxx 
表示把 xxx 这个文件的内容作为 wc 命令的输入。 
输出重定向，就是把“>”后面指定的文件作为标准输出，例如： 
echo “hello world” > xxx 
表示把 echo “hello world” 的结果输入到 xxx 文件中，而不是屏幕上。 
为了支持重定向，我们首先对简单命令的参数进行扫描，如果遇到“<”或者“>”那么就认为遇到了重定向，并把“<”或者“>”符号后面的参数作为重定向的文件名称。 
对于输入重定向，首先是以只读方式打开“<”后面的文件，并获得文件描述符，然后将该文件描述符复制给标准输入。 
对于输出重定向，首先是以写方式打开“>”后面的文件，并获得文件描述符，然后将该文件描述符复制给标准输出。 
具体实现在 predo_for_redirect() 函数中： 
3、管道的实现 
管道的实现实际上也是一种重定向的处理。对于“前”管道，类似于输入重定向，不同的是，它是把一个指定的描述符（“前”管道的输出端）复制给标准输入。对于“后”管道，类似于输出重定向，不同的是，它把一个指定的描述符（“后”管道的输入端）复制给标准输出。 
在对管道的处理上，还必须要注意管道和输入或输出重定向同时出现的情况，如果是一个“前”管道和一个输入重定向同时出现，那么优先处理输入重定向，不再从“前”管道中读取数据了。同样，如果一个“后”管道和一个输出重定向同时出现，那么优先处理输出重定向，不再把数据输出到“后”管道中。 
至此，我们已经描述了实现一个简单的 shell 解释器的全部过程，相应的代码和 makefile 在我们的网站上可以下载。希望大家能够结合代码和这篇文章，亲自动手做一次，以加深对shell 解释器的理解 
本文来自CSDN博客，转载请标明出处：file:///C:/Documents%20and%20Settings/asdf/Desktop/Web/shell的编写(特殊符号)%20-%20东之博客%20-%20CSDN博客.htm

摘要：本期的目的是向大家介绍shell的概念和基本原理，并且在此基础上动手做一个简单shell解释器。同时，还将就用到的一些 linux环境编程的知识做一定讲解。 
本文适合的读者对象 对linux环境上的c语言开发有一定经验； 对linux环境编程（比如进程、管道）有一点了解。 
概述 本章的目的是带大家了解shell的基本原理，并且自己动手做一个shell解释器。为此， 
首先，我们解释什么是shell解释器。 
其次，我们要大致了解shell解释器具有哪些功能； 
最后，我们具体讲解如何实现一个简单的 shell 解释器，并对需要用到一些 linux环境编程的知识做一定讲解，并提醒你如果想深入掌握，应该去看哪些资料。 

Shell解释器是什么？ Shell解释器是一个程序。对，是一个程序，而且，它就在我们的身边。在linux系统中，当我们输入用户名和密码登陆之后，我们就开始执行一个shell解释器程序，通常是 /bin/bash，当然也可以是别的，比如/bin/sh。（详细概念请看第一期中的shell有关部分） 
提示：在 /etc/passwd 文件中，每个用户对应的最后一项，就指定了该用户登陆之后，要执行的shell解释器程序。 
在 linux 字符界面下，输入 
man bash 
调出 bash 的帮助页面 
帮助的最开始就对bash下了一个定义： 
bash 是一个兼容于 sh 的命令语言解释器，它从标准输入或者文件中读取命令并执行。它的意图是实现 IEEE POSIX标准中对 shell和工具所规范的内容。 

Shell解释器的作用 在登陆 linux 系统之后，屏幕上就会出现一行提示符，在我的机器上，是这样的： [root@stevens root]# 这行提示符就是由bash解释器打印出来的，这说明，现在已经处于 bash 的控制之下了，也同时提示用户，可以输入命令。用户输入命令，并回车确认后，bash分析用户的命令，如果用户的命令格式正确，那么bash就按照用户的意思去做一些事情。 
比如，用户输入： 
[root@stevens root]# echo “hello, world” 
那么，bash就负责在屏幕上打印一行“hello world”。 如果，用户输入： [root@stevens root]# cd /tmp 那么，bash就把用户的当前目录改变为 /tmp。 
所以，shell解释器的作用就是对用户输入的命令进行“解释”，有了它，用户才可以在 linux 系统中任意挥洒。没有它的帮助，你纵然十八般本领在身，也施展不出。 
bash每次在“解释”完用户命令之后，又打印出一行提示符，然后继续等待用户的下一个命令。这种循环式的设计，使得用户可以始终处于 bash 的控制之下。除非你输入 exit、logout明确表示要退出 bash。 

Shell语法梗概 我们不停的命令 bash 做这做那，一般情况下它都很听话，按你的吩咐去做。可有时候，它会对你说：“嗨，老兄，你的命令我理解不了，无法执行”。例如，你输入这样的命令： [root@stevesn root]# aaaaaa bash会告诉你： bash: aaaaaa: command not found 是的，你必须说的让它能听懂，否则它就给你这么一句抱怨，当然也还会有其它的牢骚。 
那么，什么样格式的命令，它才能正确理解执行了？这就要引出shell 的语言规范了。 
Shell作为一个命令语言解释器，有一套自己的语言规范，凡是符合这个规范的命令，它就可以正确执行，否则就会报错。这个语言规范是在 IEEE POSIX的第二部分：“shell和tools规范”中定义的。关于这份规范，可以在这里看到。 
官方的东西，总是冗长而且晦涩，因为它要做到面面俱到且不能有破绽。如果读者有兴趣，可以仔细研究这份规范。而我们的目的只是理解shell的实现思想，然后去实现一个简单的 shell 解释器，所以没必要陷入枯燥的概念之中。 
现在请继续在 linux 字符界面下输入 man bash，调出 bash 的帮助页面，然后找到 “shell语法”那一部分，我们就是以这里的描述作为实现的依据。 
在 bash帮助的“shell 语法”一节，是这样来定义shell 语法的： 
l 简单命令 
简单命令是(可选的)一系列变量赋值, 紧接着是空白字符分隔的词和重定向符号, 最后以一个控制操作符结束. 第一个词指明了要执行的命令, 它被作为第 0 个参数. 其余词被作为这个命令的参数. 
这个定义可以这样来理解： 
1、 可以有变量赋值，例如 
a=10 b=20 export a b 
2、 “词”是以空白字符分隔开的，空白字符包括制表符（tab）和空格，例如： 
ls /tmp 
就是两个词，一个 ls，一个 /tmp 
3、可以出现重定向符号，重定向符号是“>”和“<”，例如： 
echo “hello world” > /tmp/log 
4、 简单命令结束于控制操作符，控制操作符包括： 
|| & && ; ;; ( ) | 
例如，用户输入： 
ls /tmp 
用户最后敲的回车键就是控制操作符 newline，表示要结束这个简单命令。 
如果用户输入： 
echo “100” ; echo “200” 
那么这是两个简单命令，第一个结束于“;”，第二个结束于newline。 
5、 简单命令的第一个词是要执行的命令，其余的词都是这个命令的参数，例如： 
echo “hello world” echo 
第一个echo 是命令，第二个词“hello world”是参数1，第三个词 echo 是参数2，而不再作为一个命令了。 
简单命令是 shell 语法中最小的命令，通过简单命令的组合，又可以得到管道命令和列表命令。 
l 管道（命令） 
管道是一个或多个简单命令的序列，两个简单命令之间通过管道符号（“|”）来分隔 
例如 
echo “hello world” | wc –l 
就是一个管道，它由两个简单命令组成，两个简单命令之间用管道符号分隔开。 
我们可以看到，管道符号“|”也是属于上面提到的控制操作符。 
根据这个定义，一个简单命令也同时是一个管道。 
管道的作用是把它前面的那个简单命令的输出作为后面那个简单命令的输入，就上面这个例子来说： 
echo “hello world” 本来是要在标准输出（屏幕）上打印 “hello world” 的，但是管道现在不让结果输出到屏幕上，而是“流”到 wc –l 这个简单命令，wc –l 就把“流”过来的数据作为它的标准输入进行计算，从而统计出结果是 1 行。 
关于管道更详细的内容，我们在后面具体实现管道的时候再说明。 
l 列表（命令）： 
列表是一个或多个管道组成的序列，两个管道之间用操作符 ;, &, &&, 或 || 分隔。我们看到，这几个操作符都属于控制操作符。 
例如 
echo “hello world” | wc –l ; echo “nice to meet you” 
就是一个列表，它由两个管道组成，管道之间用分号（;）隔开 
分号这种控制操作符仅仅表示一种执行上的先后顺序。 
l 复合命令 
这个定义比较复杂，实现起来也有相当难度，在咱们这个示例程序中，就不实现了。 
以上是 shell 语法规范的定义，我们的 shell 程序就是要以此规范为依据，实现对简单命令、管道和列表的解释。对于列表中的控制操作符，我们只支持分号（;），其它的留给读者自己来实现。 
接下来，我们具体介绍如何实现一个简单的 shell解释器。 
实现shell实例 程序主框架 主程序很简单，它在做一些必要的初始化工作之后，进入这样一个循环： 
u 打印提示符并等待用户输入 
u 获取用户输入 
u 分析用户输入 
u 解释执行； 
如果用户输入 logout或者 exit 之后，才退出这个循环。 
用类似伪代码的形式表示如下： 
while(1) { 
print_prompt(); 
get_input(); 
parse_input(); 
if(“logout” || “exit”) 
break; 
do_cmd(); 
} 


读取用户输入 如何获取用户输入？一种方法是通过 getchar() 从标准输入每次读一个字符，如果读到的字符是 ‘\n’，说明用户键入了回车键，那么就把此前读到的字符串作为用户输入的命令。 
代码如下： int len = 0; 
int ch; 
char buf[300]; 
ch = getchar(); 
while(len < BUFSIZ && ch != '\n') { 
buf[len++] = ch; 
ch = getchar(); 
} 
if(len == BUFSIZ) { 
printf("command is too long\n"); 
break; 
} 
buf[len] = '\n'; 
len++; 
buf[len] = 0; 
但是，我们注意到，在 bash 中，可以用“<-”和“->”键在命令行中左右移动，可以用上下键调用以前使用的命令，可以用退格键来删除一个字符，还可以用 tab 键来进行命令行补全。我们的shell如果也要支持这些功能，那么就必须对这些键进行处理。这样仅仅对用户输入的读取就非常麻烦了。 
实际上，任何需要一个获取用户输入的程序，都会涉及到同样的问题，如何象bash 那样处理键盘？GNU readline 库就是专门解决这个问题的，它把对键盘的操作完全封装起来，对外只提供一个简单的调用接口。有了它，对键盘的处理就不再让人头疼了。 
关于 readline 库的详细信息，可以通过 man readline 来看它的帮助页面。在我们的 shell 程序中，我是这样来使用 readline的。 
char* line; 
char prompt[200]; 
while(1) { 
set_prompt(prompt); 
if(!(line = readline(prompt))) 
break; 
。。。。。。 
} 
首先通过 set_prompt() 来设置要输出的提示符，然后以提示符作为参数调用 readline()，这个函数等待用户输入，并动态创建一块内存来保存用户输入的数据，可以通过返回的指针 line 得到这块内存。在每次处理完用户输入的命令之后，我们必须自己负责来释放这块内存。 
有了 readline 之后，我们就可以象 bash 那样使用键盘了。 
在通过 readline 获取用户输入之后，下一步就是对用户输入的命令进行分析。 

命令行分析 对命令行的分析，实际上是一个词法分析过程。学过编译原理的朋友，都听说过 lex 和yacc 的大名，它们分别是词法分析和语法分析工具。Lex 和 yacc 都有GNU的版本（open source 的思想实在是太伟大了，什么好东东都有免费的用），分别是 flex 和 bison。 
所谓“工欲善其事，必先利其器”，既然有这么好的工具，那我们就不必辛辛苦苦自己进行词法分析了。对，我们要用 lex 来完成枯燥的命令行词法分析工作。 
“去买本《lex与yacc》（中国电力出版社）来看吧。第一次学当然稍微有点难度，不过一旦掌握了，以后再碰到类似问题，就可以多一个利器，可以节省劳动力了。 
在我们的这个 shell 程序中，用 flex 来完成词法分析工作。相对语法分析来说，词法分析要简单的多。由于我们只是做一个简单的 shell，因此并没有用到语法分析，而实际上在 bash 的实现代码中，就用到了语法分析和 yacc。 
关于 lex 的细节，在这里我就不能多说了。Lex程序，通常分为三个部分，其中进行语法分析工作的就是它的第二部分： “规则”。规则定义了在词法分析过程中，遇到什么样的情况，应该如何处理。 
词法分析的思路，就是根据前面定义的“shell语法规范”来把用户输入的命令行拆解成 
首先，我们要把用户输入的命令，以空白字符（tab键或者空格）分隔成一个个的参数，并把这些参数保存到一个参数数组中。但是，这其中有几种特殊情况。 
一、如果遇到的字符是“;”、“>”、“<”或“|”，由于这些符号是管道或者列表中所用到的分隔符，因此必须把它们当作一个单独的参数。 
二、以双引号（”）括起来的字符串要作为一个单独的参数，即使其中出现了空白字符、“;”、“>”、“<”、“|”。其实，在POSIX标准中，对引号的处理相当复杂，不仅包括双引号（”），还有单引号（’）、反引号（`），在什么情况下，应该用什么样的引号以及对引号中的字符串应该如何解释，都有一大堆的条款。我们这里只是处理一种极简单的情况。 


其次，如果我们遇到换行符（’\n’），那么就结束本次命令行分析。根据前面定义的 shell 语法规范，最上层的是列表命令，因此下一步是把所有的参数作为一个列表命令来处理。 

根据这个思路，我们来看对应的 lex 规则。 
%% 


"\"" {BEGIN QUOTE;} 
[^\n"]+ {add_arg(yytext);} 
"\"" {BEGIN 0;} 
\n {BEGIN 0; do_list_cmd(); reset_args();} 
";" {add_simple_arg(yytext);} 
">" {add_simple_arg(yytext);} 
"<" {add_simple_arg(yytext);} 
"|" {add_simple_arg(yytext);} 
[^ \t\n|<>;"]+ {add_arg(yytext);} 
\n {do_list_cmd(); reset_args();} 
. ; 
%% 

我们对这些规则逐条解释： 
1－4这4条规则，目的是为了在命令行中支持引号，它们用到了 lex 规则的状态特性。 
1、"\"" {BEGIN QUOTE;} 
2、[^\n"]+ {add_arg(yytext);} 
3、"\"" {BEGIN 0;} 
4、\n {BEGIN 0; do_list_cmd(); reset_args();} 

1、 如果扫描到引号（ “），那么进入 QUOTE 状态。在这个状态下，即使扫描到空白字符或“;”、“>”、“<”、“|”，也要当作普通的字符。 
2、 如果处于 QUOTE状态，扫描到除引号和回车以外的字符，那么调用 add_arg()函数，把整个字符串加入到参数数组中。 
3、 如果处于QUOTE状态，扫描到引号，那么表示匹配了前面的引号，于是恢复到默认状态。 
4、 如果处于QUOTE状态，扫描到回车，那么结束了本次扫描，恢复到默认状态，并执行 do_list_cmd()，来执行对列表命令的处理。 


以下几条规则，是在处于默认状态的情况下的处理。 
5、";" {add_simple_arg(yytext);} 
6、">" {add_simple_arg(yytext);} 
7、"<" {add_simple_arg(yytext);} 
8、"|" {add_simple_arg(yytext);} 
9、[^ \t\n|<>;"]+ {add_arg(yytext);} 
10、\n {do_list_cmd(); reset_args();} 

5、 如果遇到分号（;），因为这是一个列表命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
6、 如果遇到 >，因为这是一个简单命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
7、 如果遇到 <，因为这是一个简单命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
8、 如果遇到管道符号（|），因为这是一个管道命令结束的操作符，所以作为一个单独的参数，执行 add_simple_arg()，将它加入参数数组。 
9、 对于不是制表符（tab）、换行符（’\n’）、| 、<、>和分号（;）以外的字符序列，作为一个普通的参数，加入参数数组。 
10、 如果遇到换行符，那么结束本次扫描，执行 do_list_cmd()，来执行对列表命令的处理。 
11、 对于任意其它字符，忽略 
通过 lex 的“规则”把用户输入的命令行分解成一个个的参数之后，都要执行 do_list_cmd() 来执行对列表命令的处理。 


命令处理 首先是对处于“shell语法规范”中最上层的列表命令的处理。 
l 列表命令的处理过程： 
依次检查参数数组中的每一个参数，如果是分号（;），那么就认为分号前面的所有参数组成了一个管道命令，调用 do_pipe_cmd() 来执行对管道命令的处理。如果扫描到最后，不再有分号出现，那么把剩下的所有参数作为一个管道命令处理。 
代码很简单： 
static void do_list_cmd() 
{ 
int i = 0; 
int j = 0; 
char* p; 
while(argbuf[i]) { 
if(strcmp(argbuf[i], ";") == 0) {// ; 
p = argbuf[i]; 
argbuf[i] = 0; 
do_pipe_cmd(i-j, argbuf+j); 
argbuf[i] = p; 
j = ++i; 
} else 
i++; 
} 
do_pipe_cmd(i-j, argbuf+j); 
} 
接下来是对管道命令的处理。 
管道命令的处理 管道是进程间通信（IPC）的一种形式，关于管道的详细解释在《unix高级环境编程》第14章：进程间通信以及《unix网络编程：第2卷：进程间通信》第4章：管道和FIFO中可以看到。 
我们还是来看一个管道的例子： 
[root@stevens root]# echo “hello world”|wc –c |wc –l 
在这个例子中，有三个简单命令和两个管道。 
第一个命令是 echo “hello world”，它在屏幕上输出 hello world。由于它后面是一个管道，因此，它并不在屏幕上输出结果，而是把它的输出重定向到管道的写入端。 
第二个命令是 wc –c，它本来需要指定输入源，由于它前面是一个管道，因此它就从这个管道的读出端读数据。也就是说读到的是 hello world，wc –c 是统计读到的字符数，结果应该是12。由于它后面又出现一个管道，因此这个结果不能输出到屏幕上，而是重定向到第二个管道的写入端。 
第三个命令是 wc –l。它同样从第二个管道的读出端读数据，读到的是12，然后它统计读到了几行数据，结果是1行，于是在屏幕上输出的最终结果是1。 
在这个例子中，第一个命令只有一个“后”管道，第三个命令只有一个“前”管道，而第二个命令既有“前”管道，又有“后”管道。 
在我们处理管道命令的do_pipe_cmd()函数中，它的处理过程是： 
首先定义两个管道 prefd 和 postfd，它们分别用来保存“前”管道和“后”管道。此外，还有一个变量 prepipe 来指示“前”管道是否有效。 
然后依次检查参数数组中每一个参数，如果是管道符号（|），那么就认为管道符号前面所有的参数组成了一个简单命令，并创建一个“后”管道。如果没有“前”管道（管道中第一个简单命令是没有“前”管道的），那么只传递“后”管道来调用do_simple_cmd()，否则，同时传递“前”管道和“后”管道来调用 do_simple_cmd()。 
执行完以后，用“前”管道来保存当前的“后”管道，并设置“前”管道有效标识prepipe，继续往后扫描。如果扫描到最后，不再有管道符号出现，那么只传递“前”管道来调用do_simple_cmd()。 
代码如下： 
int i = 0, j = 0, prepipe = 0; 
int prefd[2], postfd[2]; 
char* p; 
while(argv[i]) { 
if(strcmp(argv[i], "|") == 0) { // pipe 
p = argv[i]; 
argv[i] = 0; 
pipe(postfd); //create the post pipe 
if(prepipe) 
do_simple_cmd(i-j, argv+j, prefd, postfd); 
else 
do_simple_cmd(i-j, argv+j, 0, postfd); 
argv[i] = p; 
prepipe = 1; 
prefd[0] = postfd[0]; 
prefd[1] = postfd[1]; 
j = ++i; 
} else 
i++; 
} 
if(prepipe) 
do_simple_cmd(i-j, argv+j, prefd, 0); 
else 
do_simple_cmd(i-j, argv+j, 0, 0); 



最后，我们分析简单命令的处理过程。 
简单命令处理过程 我们已经看到，对列表命令和管道命令的处理，实际只是一个分解过程，最终命令的执行还是要由简单命令来完成。 
在简单命令的处理过程中，必须考虑以下情况： 
1、区分内部命令和外部命令 
根据简单命令的定义，它的第一个参数是要执行的命令，后面的参数作为该命令的参数。要执行的命令有两种情况： 
一种是外部命令，也就是对应着磁盘上的某个程序，例如 wc、ls等等。对这种外部命令，我们首先要到指定的路径下找到它，然后再执行它。 
二是内部命令，内部命令并不对应磁盘上的程序，例如cd、echo等等，它需要shell自己来决定该如何执行。例如对 cd 命令，shell就应该根据它后面的参数改变当前路径。 
对于外部命令，需要创建一个子进程来执行它，而对于内部命令，则没有这个必要。 
外部命令的执行，是通过 exec 函数来完成的。有六种不同形式的 exec 函数，它们可以统称为 exec 函数。我们使用的是 execv()。关于 exec的细节，请看《unix环境高级编程》第8章：进程控制。 
对于内部命令，我们目前支持五种，分别是： 
exit：退出shell解释器 
cd：改变目录 
echo：回显 
export：导入或显示环境变量 
history：显示命令历史信息 
这几个内部命令分别由 do_exit()、do_cd()、do_echo()、do_export()、do_history()来实现。 
2、处理重定向 
在简单命令的定义中，包括了对重定向的支持。重定向有多种情况，最简单的是输入重定向和输出重定向，分别对应着“<”和“>”。 
输入重定向，就是把“<”后面指定的文件作为标准输入，例如： 
wc < xxx 
表示把 xxx 这个文件的内容作为 wc 命令的输入。 
输出重定向，就是把“>”后面指定的文件作为标准输出，例如： 
echo “hello world” > xxx 
表示把 echo “hello world” 的结果输入到 xxx 文件中，而不是屏幕上。 
为了支持重定向，我们首先对简单命令的参数进行扫描，如果遇到“<”或者“>”那么就认为遇到了重定向，并把“<”或者“>”符号后面的参数作为重定向的文件名称。 
对于输入重定向，首先是以只读方式打开“<”后面的文件，并获得文件描述符，然后将该文件描述符复制给标准输入。 
对于输出重定向，首先是以写方式打开“>”后面的文件，并获得文件描述符，然后将该文件描述符复制给标准输出。 
具体实现在 predo_for_redirect() 函数中： 
3、管道的实现 
管道的实现实际上也是一种重定向的处理。对于“前”管道，类似于输入重定向，不同的是，它是把一个指定的描述符（“前”管道的输出端）复制给标准输入。对于“后”管道，类似于输出重定向，不同的是，它把一个指定的描述符（“后”管道的输入端）复制给标准输出。 
在对管道的处理上，还必须要注意管道和输入或输出重定向同时出现的情况，如果是一个“前”管道和一个输入重定向同时出现，那么优先处理输入重定向，不再从“前”管道中读取数据了。同样，如果一个“后”管道和一个输出重定向同时出现，那么优先处理输出重定向，不再把数据输出到“后”管道中。 
至此，我们已经描述了实现一个简单的 shell 解释器的全部过程，相应的代码和 makefile 在我们的网站上可以下载。希望大家能够结合代码和这篇文章，亲自动手做一次，以加深对shell 解释器的理解 


恩。。看一下。。我记得一个shell行 要被扫描9次  才会送入解释
我建议看一下那个bash教程后再写这一章
不过我忘了这个文档了
\end{lstlisting}


\begin{lstlisting}
                               +-------------+      单引号
    +------------------------->|             +--------------------------+
    |  +---------------------->|1.分隔成记号 +--------------------+     |
    |  |   +------------------>|             |      双引号        |     |
    |  |   |                   +-------------+                    |     |
    |  |   |                          ||                          |     |
    |  |   |读取下一个命令            \/                          |     |
    |  |   |     +-------------------------------------------+    |     |
    |  |   +-----+              2.检验第一个记号             |    |     |
    |  |         |开放的关键字                    其他关键字 |    |     |
    |  |         |                  非关键字                 |    |     |
    |  |         +-------------------------------------------+    |     |
    |  |                              ||                          |     |
    |  |                              \/                          |     |
    |  |                +-------------------------+               |     |
    |  |  扩展别名      |       3. 检验第一个记号 |               |     |
    |  +----------------+别名                     |               |     |
    |                   |          不是别名       |               |     |
    |                   +-------------------------+               |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |                           +--------------+                  |     |
    |                           | 4.大括号扩展 |                  |     |
    |                           +--------------+                  |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |                           +--------------+                  |     |
    |                           | 5.~符号扩展  |                  |     |
    |                           +--------------+                  |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |                           +--------------+       双引号     |     |
    |                           |  6.参数扩展  |<-----------------+     |
    |                           +--------------+                        |
    |                                 ||                                |
    |                                 \/                                |
    |                    +------------------------------+               |
    |                    |  7.命令替换(嵌套命令行处理)  |               |
    |                    +------------------------------+               |
    |                                 ||                                |
    |                                 \/                                |
    |                           +--------------+      双引号            |
    |                           |  8.算术扩展  +------------------+     |
    |                           +--------------+                  |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |                           +--------------+                  |     |
    |                           |  9.单词分割  |                  |     |
    |                           +--------------+                  |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |                           +--------------+                  |     |
    |                           | 10.路径名扩展|                  |     |
    |                           +--------------+                  |     |
    |                                 ||                          |     |
    |                                 \/                          |     |
    |               +----------------------------------------+    |     |
    |               | 11.命令查寻：函数，内置命令，可执行文件|<---+-----+
    |               +----------------------------------------+
    |                                 ||
    |                                 \/
    |将参数带入下一个命令        +-------------+
    +----------eval--------------+ 12.运行命令 |
                                 +-------------+





结合上面的插图，这里给出命令行的12个步骤。

1、将命令行分成由固定元字符集分隔的记号；

SPACE, TAB, NEWLINE, ; , (, ), <, >, |, &

记号类型包括单词，关键字，I/O重定向符和分号。

2、检测每个命令的第一个记号，查看是否为不带引号或反斜线的关键字。

如果是一个开放的关键字，如if和其他控制结构起始字符串，function，{或(，则命令实际上为一复合命令。shell在内部对复合命令进行处理，读取下一个命令，并重复这一过程。如果关键字不是复合命令起始字符串(如then等一个控制结构中间出现的关键字)，则给出语法错误信号。

3、依据别名列表检查每个命令的第一个关键字；

如果找到相应匹配，则替换其别名定义，并退回第一步;否则进入第4步。该策略允许递归别名，还允许定义关键字别名。如alias procedure=function

4、执行大括号扩展，例如a{b,c}变成ab ac


5、如果~位于单词开头，用$HOME替换~。

使用usr的主目录替换~user。

6、对任何以符号$开头的表达式执行参数(变量)替换;


7、对形式$(string)的表达式进行命令替换；

这里是嵌套的命令行处理。

8、计算形式为$((string))的算术表达式；


9、把行的参数，命令和算术替换部分再次分成单词，这次它使用$IFS中的字符做分割符而不是步骤1的元字符集；

 

10、对出现*, ?, [ / ]对执行路径名扩展，也称为通配符扩展；

11、按命令优先级表(跳过别名)，进行命令查寻；

12、设置完I/O重定向和其他操作后执行该命令。

二、关于引用

1、单引号跳过了前10个步骤，不能在单引号里放单引号
2、双引号跳过了步骤1~5，步骤9~10，也就是说，只处理6~8个步骤。

也就是说，双引号忽略了管道字符，别名，~替换，通配符扩展，和通过分隔符分裂成单词。
双引号里的单引号没有作用，但双引号允许参数替换，命令替换和算术表达式求值。可以在双引号里包含双引号，方式是加上转义符"\"，还必须转义$, `, \。

三、eval的作用；

eval的作用是再次执行命令行处理，也就是说，对一个命令行，执行两次命令行处理。这个命令要用好，就要费一定的功夫。我举两个例子，抛砖引玉。

1、例子1：用eval技巧实现shell的控制结构for

用eval技巧实现shell的控制结构for。

 
[root@home root]# cat myscript1
#!/bin/sh
evalit(){
        if [ $cnt = 1 ];then
                eval $@
                return
        else
                let cnt=cnt-1
                evalit $@
        fi
        eval $@
}
cnt=$1
echo $cnt | egrep "^[1-9][0-9]*$" >/dev/null
if [ $? -eq 0 ]; then
        shift
        evalit $@
else
        echo 'ERROR!!! Check your input!'
fi
[root@home root]# ./myscript1 3 hostname
home
home
home
[root@home root]# ./myscript1 5 id |cut -f1 -d' '
uid=0(root)
uid=0(root)
uid=0(root)
uid=0(root)
uid=0(root)

注意：bash里有两个很特殊的变量，它们保存了参数列表。

 

$*，保存了以$IFS指定的分割符所分割的字符串组。
$@，原样保存了参数列表，也就是"$1""$2"...

这里我使用了函数递归以及eval实现了for结构。
当执行eval $@时，它经历了步骤如下：
第1步，分割成eval $@
第6步，扩展$@为hostname
第11步，找到内置命令eval
重复一次命令行处理，第11步，找到hostname命令，执行。

注意：也许有人想当然地认为，何必用eval呢？直接$@来执行命令就可以了嘛。

例子2：一个典型错误的例子

错误！这里给个典型的例子大家看看。

 
[root@home root]# a="id | cut -f1 -d' '"
[root@home root]# $a
id：无效选项 -- f
请尝试执行‘id --help’来获取更多信息。
[root@home root]# eval $a
uid=0(root)

如果命令行复杂的话(包括管道或者其他字符)，直接执行$a字符串的内容就会出错。分析如下。
$a的处理位于第6步──参数扩展，也就是说，跳过了管道分析，于是"|", "cut", "-f1", "-d"都变成了id命令的参数，当然就出错啦。
但使用了eval，它把第一遍命令行处理所得的"id", "|", "cut", "-f1", "-d"这些字符串再次进行命令行处理，这次就能正确分析其中的管道了。

总而言之：要保证你的命令或脚本设计能正确通过命令行处理，跳过任意一步，都可能造成意料外的错误！


\end{lstlisting}



表达式求值
D2S自身不支持表达式求值，D2S脚本中表达式求值借助命令calc命令完成。calc命令的格式如下：
\begin{lstlisting}
calc expr
\end{lstlisting}
例如：
\begin{lstlisting}
let var1 = 12
let var2 = 73.2
let res = ${calc ($var1+$(var)1/2+$var2)/3.2}
echo $res
\end{lstlisting}

\begin{lstlisting}

表达式求值，可直接复制到VC中运行。

#include<stdio.h>
#include<malloc.h>
#include<string.h>
#include<stdlib.h>

static int gv_a;

typedef struct list    //创建队列元素型
{
	char str[10];
	struct list*pNext;
}LIST;
typedef struct queue	//创建队列表型
{
	LIST *front;
	LIST *rear;
}QUEUE;

typedef struct oprstack		//创建运算符栈型
{
	char opr[100];
	int a;
}OPRSTACK;

typedef struct valstack		//创建运算栈型
{
	float val[30];
	int a;
}VALSTACK;

typedef struct element       //创建表达式栈元素型
{
	char c;
	struct element *pNext;

}ENT;

typedef struct stack			//创建表达式栈 型
{
	ENT *pTop;
	ENT *bottom;
}STACK;



bool calc(char *str,float *result);
float evaluationofexpression(char *str);

int main(void)
{
	char str[50];
	float result;
	printf("请输入要计算的表达式：");
	scanf("%s",str);
	result = evaluationofexpression(str);
	if (gv_a)
		return 0;
	printf("结果：%f",result);
	printf("\n");


	return 0;
}
/*=======================================================*/
/*==================不带括号表达式求值===================*/
/*=======================================================*/
void insert_char(char *p,char ent,int site)			 //向字符串中插入一个元素
{
	int i=0,j;

	while (p[i]!='\0')
		++i;
	if(site>i)
	{
		p[i] = ent;
		p[i+1] = '\0';
		return;
	}
	for (j=i;j>=site;--j)
	{
		p[j+1] = p[j];
	}
	p[site] = ent;

}

void del_char(char *p,int site)					//删除字符串中的一个元素
{
	int i=0,j=site;

	while (p[i] != '\0')
		++i;
	if (site>i)
		return;
	while (p[j] != '\0')
	{
		p[j] = p[j+1];
		++j;
	}


}
int find_str(char *p1,char *p2)			//寻找字符串在另一个字符串中第一次出现的位置，失败返回-1.
{
	int i=0,j=0,a=1;

	while (p1[i]!='\0')
	{
		j = 0;
		a = 1;
		while (p2[j]!='\0')
		{
			if (p1[i+j] != p2[j])
			{	
				a = 0;
				break;
			}

			++j;
		}
		if (a == 1)
			return i;
		
		++i;

	}

	return -1;
}

void form_expression(char *p)			//格式化表达式
{
	char *tmp1 = "--";
	char *tmp2 = "-";
	char *tmp3 = "!";
	int i=0,s1,s2,s3,j;
	
	//printf("AAAA");
	s1 = find_str(p,tmp1);			//将字符串中的“——”替换成“+”
	//printf("AAAA");
	while (s1 != -1)
	{
		del_char(p,s1);
		del_char(p,s1);
		insert_char(p,'+',s1);
		s1 = find_str(p,tmp1);

	}
	//printf("%d",s1);
	//printf("AAAA");
	if (p[0] == '-')			//如果第一个字符是‘-’则在前面加0
		insert_char(p,'0',0); 
	//printf("AAAA");

	s2 = find_str(p,tmp2);			//将表达式中的‘-’替换成‘！’
	for (j=0;p[j]!='\0';++j)
	{
		if (p[j] == '-' && p[j-1]>=48 && p[j-1]<=57)
			insert_char(p,'+',j);



	}


	//printf("AAAA\n");
	s3 = find_str(p,tmp3);

	while (s3 != -1)			//将表达式中的‘！’替换成“+-”
	{
		del_char(p,s3);
		insert_char(p,'-',s3);
		insert_char(p,'+',s3);
		s3 = find_str(p,tmp3);
	}
	//printf("AAAA\n");


}

void initlist(QUEUE*p)	//初始化链表
{
	p->front = (LIST*)malloc(sizeof(LIST));
	p->rear = p->front ;
	p->front ->pNext = NULL;

}
void addlist(QUEUE*p,char *c)               //入队
{
	LIST *temp = (LIST*)malloc(sizeof(LIST));
	temp->pNext = NULL;
	strcpy(p->rear ->str ,c);
	p->rear ->pNext = temp;
	p->rear = temp;
}
void dellist(QUEUE *p,char *c)			// 出队
{
	if (p->front == p->rear )
	{
		strcpy(c,"!");
		return;
	}
	LIST *temp;
	temp = p->front;
	p->front = p->front ->pNext ;
	strcpy(c,temp->str );
	free(temp);
	
}

void oprstack(OPRSTACK*p)		//初始化运算符栈
{
	p->a = 0;

}

char delstack(OPRSTACK*p)     //运算符栈 出栈
{
	char temp;
	if (p->a  == 0 )
		return '!';
	temp = p->opr [p->a ];
	p->a  = p->a -1;
	return temp;

}
void addstack(OPRSTACK*p,char c)		//运算符栈 入栈
{
	p->a = p->a +1;
	p->opr[p->a ] = c;
}

void initvalstack(VALSTACK *p)			//初始化运算栈
{
	p->a = 0;
}

float delvalstack(VALSTACK *p)			//运算栈 出栈
{
	float temp;
	if (p->a == 0)
		exit(0);
	temp = p->val [p->a ];
	p->a = p->a -1;
	return temp;
}

void addvalstack(VALSTACK *p,float val)		//运算栈 入栈
{
	p->a = p->a +1;
	p->val [p->a ] = val;
}

int opr_assign(char opr)			//运算符优先级赋值
{
	if ((opr == '+')||(opr =='-'))
		return 1;
	if ((opr == '*')||(opr == '/'))
		return 2;
	else
		return 0;
		
	
}

int opr_compare(char a,char b) //运算符优先级比较：a>b 返回1，a<b返回-1，相等返回0
{
	int opr1,opr2;
	opr1 = opr_assign(a);
	opr2 = opr_assign(b);
	
	if (opr1>opr2)
		return 1;
	else if (opr1<opr2)
		return -1;
	else
		return 0;
}

bool error_correct(char *str)		//改正表达式中的非法输入
{
	int i;
	for (i = 0;str[i]!='\0';++i)
	{
		if ((str[i]!=42)&&(str[i]!=43)&&(str[i]!=45)&&(str[i]!=46)&&(str[i]!=47)&&(str[i]<48 || str[i]>57))
			return false;
	}
	return true;
}

float resultval(float a,float b,char c)			//计算两个双精度的运算结果
{
	float result;
	if (c == '+')
		result = a+b;
	else if (c == '-')
		result = a-b;
	else if (c == '*')
		result = a*b;
	else
		result = a/b;
	return result;

}


void freequeue(QUEUE *p)			//释放队列所占用的内存空间
{
	char temp[50];
	while (p->front != p->rear )
		dellist(p,temp);
	free(p->rear );
}
bool ec_expression(char *p)		//纠错
{
	int i=0;
	int site;
	while (p[i]!='\0')
		++i;
	//printf("%s\n",p);
	if (p[i-1]>57 || p[i-1]<48)
		return false;

	site = find_str(p,"++")	;
	if (site!=-1)
		return false;

	site = find_str(p,"+*")	;
	if (site!=-1)
		return false;

	site = find_str(p,"+/");	
	if (site!=-1)
		return false;

	site = find_str(p,"+.")	;
	if (site!=-1)
		return false;

	site = find_str(p,"-+")	;
	if (site!=-1)
		return false;

	site = find_str(p,"-*");	
	if (site!=-1)
		return false;
	site = find_str(p,"-/");	
	if (site!=-1)
		return false;

	site = find_str(p,"-.")	;
	if (site!=-1)
		return false;

	site = find_str(p,"*+")	;
	if (site!=-1)
		return false;

	site = find_str(p,"**")	;
	if (site!=-1)
		return false;

	site = find_str(p,"*/")	;
	if (site!=-1)
		return false;

	site = find_str(p,"*.")	;
	if (site!=-1)
		return false;

	site = find_str(p,"/+")	;
	if (site!=-1)
		return false;
	site = find_str(p,"/*")	;
	if (site!=-1)
		return false;
	site = find_str(p,"//")	;
	if (site!=-1)
		return false;
	site = find_str(p,"/.")	;
	if (site!=-1)
		return false;
	return true;

}
/*==================不带括号表达式的值=======================*/

bool calc(char *str,float *result)       //计算字符串表达式结果
{
	QUEUE queue;
	OPRSTACK oprstk;
	VALSTACK valstk;
	OPRSTACK temp1,temp2;
	int i,j;
	char t,tstr[10],t1[2];
	int cmp;
	char que[10];
	float temp3;
	float tmp1,tmp2,res;



	initlist(&queue);           //  完成各个线性表的初始化
	initvalstack(&valstk);		  
	oprstack(&oprstk); 
	oprstack(&temp1);
	oprstack(&temp2);

	addstack(&oprstk,'#');

	
	
	if (error_correct(str) == false )
	{	
		gv_a = 1;
		printf("表达式中存在非法字符！");
		return false;
	}

	if (ec_expression(str) == false)
	{
		gv_a = 1;
		printf("表达式格式不正确！");
		return false;
	}
	
	form_expression(str);
	//printf("%s\n",str);

	for (i = 0;str[i]!='\0';++i)
	{
		if ((str[i]>=48 && str[i]<=57)||(str[i] == 46)||str[i] == 45)     //当字符是0-9数字 或 “.” 或 “-”时进行压栈temp1
		{
			 addstack(&temp1,str[i]);   //调试  ：3
			
		}
		else
		{
			while (temp1.a != 0)            //T
			{
				t = delstack(&temp1);
				addstack(&temp2,t);

			}
			for (j=0;temp2.a !=0;++j)                //T
			{
				tstr[j] = delstack(&temp2);
			}
			tstr[j] = '\0';
			addlist(&queue,tstr); 
			//printf("%s\n",tstr);

			cmp = opr_compare(str[i],oprstk.opr [oprstk.a ]);
			//printf("%d\n",cmp);
			
			if (cmp<=0)                      //T
			{
				while (oprstk.opr [oprstk.a ]!='#')       //T
				{
					t1[0] =  delstack(&oprstk);
				//	printf("%c",t1[0]);
					t1[1] = '\0';
					addlist(&queue,t1);

				}
				addstack(&oprstk,str[i]);

			}
			else        //T
			{
				addstack(&oprstk,str[i]);

			}

		}             //T

	}
		while (temp1.a != 0)               //T
			{
				t = delstack(&temp1);
				 addstack(&temp2,t);

			}
		for (j=0;temp2.a !=0;++j)               //T
			{
				tstr[j] = delstack(&temp2);
			}
		tstr[j] = '\0';
		addlist(&queue,tstr); 
		while (oprstk.opr [oprstk.a ]!='#')
		{
			t1[0] =  delstack(&oprstk);
			t1[1] = '\0';
			addlist(&queue,t1);	
		}

		 //tralist(&queue);                 //调试 ：队列错误



		while (queue.front != queue.rear )            //T
		{
			 dellist(&queue,que);
			 //printf("%c\n",que[0]);			//调试：que正常
			 if ((que[0]>=48) && (que[0]<=57)||que[0] == 45)             //T
			 {
				 
				 temp3 = (float)atof(que);
				 //printf("%f\n",temp3);		//调试：temp3正常
				 addvalstack(&valstk,temp3);

			 }
			 else                                   //T
			 { 
				// printf("%c\n",que[0]);        //调试：que[0]正常
				 tmp1 = delvalstack(&valstk);
				 tmp2 = delvalstack(&valstk);
				 res =  resultval(tmp2,tmp1,que[0]);
				 //printf("%f",res);
				 addvalstack(&valstk,res);			
				 
			 }
		}
			
		*result = delvalstack(&valstk);
		freequeue(&queue);					//	释放队列queue所占用的空间
			 
		return true;

}


/*=======================================================*/
/*==================带括号表达式求值=====================*/
/*=======================================================*/

void initstk(STACK *p)                  //初始化栈
{
	p->bottom = (ENT*)malloc(sizeof(ENT));
	p->pTop = p->bottom  ;
	p->bottom ->pNext = NULL;
}

void addstk(STACK *p,char ent)			//压栈
{
	ENT *temp = (ENT*)malloc(sizeof(ENT));
	temp->c = ent;
	temp->pNext = p->pTop ;
	p->pTop = temp;
}

char delstk(STACK *p)				//出栈
{
	
	ENT *temp;
	char t;
	if (p->pTop == p->bottom )
		return '!';
	temp = p->pTop ;
	p->pTop = p->pTop ->pNext ;
	t = temp->c ;
	free(temp);
	return t;

}

void freestack(STACK *p)
{
	while (p->pTop != p->bottom )
		delstk(p);
	free(p->bottom );
}
bool check_brackets(char *p)			//检查括号
{	
	OPRSTACK temp;
	int i;
	temp.a = 0;

	for (i=0;p[i]!='\0';++i)
	{
		if (p[i] == 40)
			addstack(&temp,p[i]);
		if (p[i] == 41)
			if (temp.a = 0)
				return false;
			else
				delstack(&temp);

		
	}

	if (temp.a == 0)
		return true;
	else
		return false;

}
bool check_obs(char *p)
{
	int i;
	for (i=0;p[i]!='\0';++i)
	{
		if (p[i] == '(')
			if (i == 0)
			{	if ((p[i+1]<48 || p[i+1]>57 )&& p[i+1]!=45 && p[i+1]!=40)
					return false;
			}
			else
			{
				if ((p[i-1]!='+') && (p[i-1]!='-') &&(p[i-1]!='*')&& (p[i-1]!='/') && p[i-1]!=40)
					return false;
				if ((p[i+1]<48 || p[i+1]>57 ) && p[i+1]!=45 && p[i+1]!=40)
					return false;
			}

		//	printf("AAAAA\n");
		if (p[i] == ')')
			if (p[i+1] == '\0')
			{	if ((p[i-1]<48 || p[i-1]>57) && p[i-1]!=41)
					return false;
			}
			else
			{
				if (p[i+1]!='+' && p[i+1]!='-' && p[i+1]!='*'&& p[i+1]!='/'&&p[i+1]!=41)
					return false;
				if ((p[i-1]<48 || p[i-1]>57) && p[i-1]!=41)
					return false;

			}

	}
	return true;
}

/*================表达式求值===================*/
float evaluationofexpression(char *str)            //表达式求值
{
	STACK stk;
	STACK stk1,stk2;
	char tmp1,tstr[50],tmp3,tstr1[50];
	int i,j,k,l,m,n,o;
	float ftmp;
	char *string,fstring[50];
	int decpt,  sign;
	float result;
	gv_a = 0;


	initstk(&stk);
	initstk(&stk1);
	initstk(&stk2);

	if (check_brackets(str) == false)
	{
		printf("括号不匹配！");
		gv_a = 1;
	}
	if (check_obs(str) == false)
	{
		printf("格式错误！");
		gv_a = 1;
	}
	
	


	//printf("%s",str);        //调试：参数正常
	for (i=0;str[i]!='\0';++i)
	{
		if (str[i]!=41)					//如果不是右括号则进行压栈 str
			addstk(&stk,str[i]);
		else
		{
			while (stk.pTop ->c !=40)	//如果是右括号则出栈 str 将出栈元素进行压栈 str1知道出现左括号			
			{
				tmp1 =  delstk(&stk);
				addstk(&stk1,tmp1);

			}

			delstk(&stk);				//删除str栈中的左括号
			j = 0;
			while (stk1.pTop != stk1.bottom )	//将str1中的元素全部转入tsrt数组中  以纠正顺序
			{
				tstr[j] = delstk(&stk1);
					++j;
			}
			tstr[j] = '\0';

			calc(tstr,&ftmp);			
			string = fcvt(ftmp,5,&decpt,&sign);
		//	printf("%s\n",string);
		//	printf("%d\n",decpt);
		//	printf("%d\n",sign);
			fstring[49] = '\0';
			o = 0;
			while (fstring[o]!='\0')
			{	
				fstring[o] = 65;
				++o;
			}
			
			
			if (sign == 0)
				if (decpt <= 0)
				{
					fstring[0] = '0';
					fstring[1] = '.';
					
					for (m = 0;m<-decpt;++m)
					{
						fstring[2+m] = '0';
					}


				}
				else
					fstring[decpt] = 46;

			else
			{
				if (decpt <= 0)
				{
					fstring[0] = '-';
					fstring[1] = '0';
					fstring[2] = '.';
					for (m = 0;m<-decpt;++m)
					{
						fstring[3+m] = '0';
					}
				}
				else
				{
					fstring[0] = '-';
					fstring[decpt+1] = '.';
				}
			}
			m = 0;
			n = 0;
			while (string[n]!='\0')
			{
				if (fstring[m] == 65)
				{	
					fstring[m] = string[n];
					++n;
				}
				++m;

			}
			fstring[m] = '\0';
		/*	for (n=0;string[n]!='\0';++m)
			{
				if (m == decpt)
					fstring[m] = '.';
				else
				{
					fstring[m] = string[n];
					++n;
				}

			}
			fstring[m] = '\0';
			printf("%s\n",fstring);
			//printf("%d\n",n);
		//	printf("%d\n",m);
		//	printf("%s\n",fstring);
			*/

			for (k=0;fstring[k]!='\0';++k)
			{
				addstk(&stk,fstring[k]);
			}



		}




	}
	//travstk(&stk);
                  //调试：正常
	
 	while (stk.pTop != stk.bottom )
	{
		//printf("AAAA\n");
		tmp3 =  delstk(&stk);
		addstk(&stk2,tmp3);

		//printf("%c\n",tmp3);

	}
	//printf("AAAA\n");				//调试：错误！！！
	 //travstk(&stk2);


	for (l=0;stk2.pTop != stk2.bottom  ;++l)
		tstr1[l] = delstk(&stk2);
	tstr1[l] = '\0';
	//printf("%s\n",tstr1);
	calc(tstr1,&result);
	//printf("AAAA");
	freestack(&stk);				//	释放stk stk1 stk2 所占用的内存空间
	freestack(&stk1);
	freestack(&stk2);

	return result;

}
\end{lstlisting}

我建议自己把Lua的程序看完了后再研究这一章的实现。


\begin{lstlisting}

在shell中常用的特殊符号罗列如下：

# ; ;; . , / \\ 'string'| ! $ ${} $? $$ $*

\"string\"* ** ? : ^ $# $@ `command`{} [] [[]] () (())

|| && {xx,yy,zz,...}~ ~+ ~- & \\< ...\\> + - %= == !=

# 井号 (comments)
这几乎是个满场都有的符号，除了先前已经提过的\"第一行\"
#!/bin/bash
井号也常出现在一行的开头，或者位于完整指令之后，这类情况表示符号后面的是注解文字，不会被执行。
# This line is comments.
echo \"a = $a\" # a = 0
由于这个特性，当临时不想执行某行指令时，只需在该行开头加上 # 就行了。这常用在撰写过程中。
#echo \"a = $a\" # a = 0
如果被用在指令中，或者引号双引号括住的话，或者在倒斜线的后面，那他就变成一般符号，不具上述的特殊功能。

~ 帐户的 home 目录
算是个常见的符号，代表使用者的 home 目录：cd ~；也可以直接在符号后加上某帐户的名称：cd ~user或者当成是路径的一部份：~/bin
~+ 当前的工作目录，这个符号代表当前的工作目录，她和内建指令 pwd的作用是相同的。
# echo ~+/var/log
~- 上次的工作目录，这个符号代表上次的工作目录。
# echo ~-/etc/httpd/logs

; 分号 (Command separator)
在 shell 中，担任\"连续指令\"功能的符号就是\"分号\"。譬如以下的例子：cd ~/backup ; mkdir startup ;cp ~/.* startup/.

;; 连续分号 (Terminator)
专用在 case 的选项，担任 Terminator 的角色。
case \"$fop\" inhelp) echo \"Usage: Command -help -version filename\";;version) echo \"version 0.1\" ;;esac

. 逗号 (dot,就是“点”)
在 shell 中，使用者应该都清楚，一个 dot 代表当前目录，两个 dot 代表上层目录。
CDPATH=.:~:/home:/home/web:/var:/usr/local
在上行 CDPATH 的设定中，等号后的 dot 代表的就是当前目录的意思。
如果档案名称以 dot 开头，该档案就属特殊档案，用 ls 指令必须加上 -a 选项才会显示。除此之外，在 regularexpression 中，一个 dot 代表匹配一个字元。

'string' 单引号 (single quote)
被单引号用括住的内容，将被视为单一字串。在引号内的代表变数的$符号，没有作用，也就是说，他被视为一般符号处理，防止任何变量替换。

\"string\" 双引号 (double quote)
被双引号用括住的内容，将被视为单一字串。它防止通配符扩展，但允许变量扩展。这点与单引数的处理方式不同。
heyyou=homeecho \"$heyyou\" # We get home

`command` 倒引号 (backticks)
在前面的单双引号，括住的是字串，但如果该字串是一列命令列，会怎样？答案是不会执行。要处理这种情况，我们得用倒单引号来做。
fdv=`date +%F`echo \"Today $fdv\"
在倒引号内的 date +%F 会被视为指令，执行的结果会带入 fdv 变数中。

, 逗点 (comma，标点中的逗号)
这个符号常运用在运算当中当做\"区隔\"用途。如下例
#!/bin/bashlet \"t1 = ((a = 5 + 3, b = 7 - 1, c = 15 / 3))\"echo \"t1= $t1, a = $a, b = $b\"

/ 斜线 (forward slash)
在路径表示时，代表目录。
cd /etc/rc.dcd ../..cd /
通常单一的 / 代表 root 根目录的意思；在四则运算中，代表除法的符号。
let \"num1 = ((a = 10 / 2, b = 25 / 5))\"

\\ 倒斜线
在交互模式下的escape 字元，有几个作用；放在指令前，有取消 aliases的作用；放在特殊符号前，则该特殊符号的作用消失；放在指令的最末端，表示指令连接下一行。
# type rmrm is aliased to `rm -i'# \\rm ./*.log
上例，我在 rm 指令前加上 escape 字元，作用是暂时取消别名的功能，将 rm 指令还原。
# bkdir=/home# echo \"Backup dir, \\$bkdir = $bkdir\"Backup dir,$bkdir = /home
上例 echo 内的 \\$bkdir，escape 将 $ 变数的功能取消了，因此，会输出 $bkdir，而第二个 $bkdir则会输出变数的内容 /home。

| 管道 (pipeline)
pipeline 是 UNIX 系统，基础且重要的观念。连结上个指令的标准输出，做为下个指令的标准输入。
who | wc -l
善用这个观念，对精简 script 有相当的帮助。

! 惊叹号(negate or reverse)
通常它代表反逻辑的作用，譬如条件侦测中，用 != 来代表\"不等于\"
if [ \"$?\" != 0 ]thenecho \"Executes error\"exit 1fi
在规则表达式中她担任 \"反逻辑\" 的角色
ls a[!0-9]
上例，代表显示除了a0, a1 .... a9 这几个文件的其他文件。

: 冒号
在 bash 中，这是一个内建指令：\"什么事都不干\"，但返回状态值 0。
:
echo $? # 回应为 0
: > f.$$
上面这一行，相当于 cat /dev/null >f.$$。不仅写法简短了，而且执行效率也好上许多。
有时，也会出现以下这类的用法
: ${HOSTNAME?} ${USER?} ${MAIL?}
这行的作用是，检查这些环境变数是否已设置，没有设置的将会以标准错误显示错误讯息。像这种检查如果使用类似 test 或 if这类的做法，基本上也可以处理，但都比不上上例的简洁与效率。

? 问号 (wild card)
在文件名扩展(Filename expansion)上扮演的角色是匹配一个任意的字元，但不包含 null 字元。
# ls a?a1
善用她的特点，可以做比较精确的档名匹配。

* 星号 (wild card)
相当常用的符号。在文件名扩展(Filename expansion)上，她用来代表任何字元，包含 null 字元。
# ls a*a a1 access_log
在运算时，它则代表 \"乘法\"。
let \"fmult=2*3\"
除了内建指令 let，还有一个关于运算的指令expr，星号在这里也担任\"乘法\"的角色。不过在使用上得小心，他的前面必须加上escape 字元。

** 次方运算
两个星号在运算时代表 \"次方\" 的意思。
let \"sus=2**3\"echo \"sus = $sus\" # sus = 8

$ 钱号(dollar sign)
变量替换(Variable Substitution)的代表符号。
vrs=123echo \"vrs = $vrs\" # vrs = 123
另外，在 Regular Expressions 里被定义为 \"行\" 的最末端 (end-of-line)。这个常用在grep、sed、awk 以及 vim(vi) 当中。

${} 变量的正规表达式
bash 对 ${} 定义了不少用法。以下是取自线上说明的表列
${parameter:-word} ${parameter:=word} ${parameter:?word} ${parameter:+word} ${parameterffset} ${parameterffset:length} ${!prefix*} ${#parameter} ${parameter#word} ${parameter##word} ${parameter%word} ${parameter%%word} ${parameter/pattern/string} ${parameter//pattern/string}

$*
$* 引用script的执行引用变量，引用参数的算法与一般指令相同，指令本身为0，其后为1，然后依此类推。引用变量的代表方式如下：
$0, $1, $2, $3, $4, $5, $6, $7, $8, $9, ${10}, ${11}.....
个位数的，可直接使用数字，但两位数以上，则必须使用 {} 符号来括住。
$* 则是代表所有引用变量的符号。使用时，得视情况加上双引号。
echo \"$*\"
还有一个与 $* 具有相同作用的符号，但效用与处理方式略为不同的符号。

$@
$@ 与 $* 具有相同作用的符号，不过她们两者有一个不同点。
符号 $* 将所有的引用变量视为一个整体。但符号 $@ 则仍旧保留每个引用变量的区段观念。

$#
这也是与引用变量相关的符号，她的作用是告诉你，引用变量的总数量是多少。
echo \"$#\"

$? 状态值 (status variable)
一般来说，UNIX(linux) 系统的进程以执行系统调用exit()来结束的。这个回传值就是status值。回传给父进程，用来检查子进程的执行状态。
一般指令程序倘若执行成功，其回传值为 0；失败为 1。
tar cvfz dfbackup.tar.gz /home/user > /dev/nullecho\"$?\"$$
由于进程的ID是唯一的，所以在同一个时间，不可能有重复性的 PID。有时，script会需要产生临时文件，用来存放必要的资料。而此script亦有可能在同一时间被使用者们使用。在这种情况下，固定文件名在写法上就显的不可靠。唯有产生动态文件名，才能符合需要。符号$$或许可以符合这种需求。它代表当前shell 的 PID。
echo \"$HOSTNAME, $USER, $MAIL\" > ftmp.$$
使用它来作为文件名的一部份，可以避免在同一时间，产生相同文件名的覆盖现象。
ps: 基本上，系统会回收执行完毕的 PID，然后再次依需要分配使用。所以 script 即使临时文件是使用动态档名的写法，如果script 执行完毕后仍不加以清除，会产生其他问题。

( ) 指令群组 (command group)
用括号将一串连续指令括起来，这种用法对 shell 来说，称为指令群组。如下面的例子：(cd ~ ; vcgh=`pwd` ;echo $vcgh)，指令群组有一个特性，shell会以产生 subshell来执行这组指令。因此，在其中所定义的变数，仅作用于指令群组本身。我们来看个例子
# cat ftmp-01#!/bin/basha=fsh(a=incg ; echo -e \"\\n $a \\n\")echo $a#./ftmp-01incgfsh
除了上述的指令群组，括号也用在 array 变数的定义上；另外也应用在其他可能需要加上escape字元才能使用的场合，如运算式。

(( ))
这组符号的作用与 let 指令相似，用在算数运算上，是 bash 的内建功能。所以，在执行效率上会比使用 let指令要好许多。
#!/bin/bash(( a = 10 ))echo -e \"inital value, a = $a\\n\"(( a++))echo \"after a++, a = $a\"

{ } 大括号 (Block of code)
有时候 script 当中会出现，大括号中会夹着一段或几段以\"分号\"做结尾的指令或变数设定。
# cat ftmp-02#!/bin/basha=fsh{a=inbc ; echo -e \"\\n $a \\n\"}echo $a#./ftmp-02inbcinbc
这种用法与上面介绍的指令群组非常相似，但有个不同点，它在当前的 shell 执行，不会产生 subshell。
大括号也被运用在 \"函数\" 的功能上。广义地说，单纯只使用大括号时，作用就像是个没有指定名称的函数一般。因此，这样写 script也是相当好的一件事。尤其对输出输入的重导向上，这个做法可精简 script 的复杂度。

此外，大括号还有另一种用法，如下
{xx,yy,zz,...}
这种大括号的组合，常用在字串的组合上，来看个例子
mkdir {userA,userB,userC}-{home,bin,data}
我们得到 userA-home, userA-bin, userA-data, userB-home, userB-bin,userB-data, userC-home, userC-bin,userC-data，这几个目录。这组符号在适用性上相当广泛。能加以善用的话，回报是精简与效率。像下面的例子
chown root /usr/{ucb/{ex,edit},lib/{ex?.?*,how_ex}}
如果不是因为支援这种用法，我们得写几行重复几次呀！

[ ] 中括号
常出现在流程控制中，扮演括住判断式的作用。if [ \"$?\" != 0 ]thenecho \"Executes error\"exit1fi
这个符号在正则表达式中担任类似 \"范围\" 或 \"集合\" 的角色
rm -r 200[1234]
上例，代表删除 2001, 2002, 2003, 2004 等目录的意思。

[[ ]]
这组符号与先前的 [] 符号，基本上作用相同，但她允许在其中直接使用 || 与&& 逻辑等符号。
#!/bin/bashread akif [[ $ak > 5 || $ak< 9 ]]thenecho $akfi

|| 逻辑符号
这个会时常看到，代表 or 逻辑的符号。

&& 逻辑符号
这个也会常看到，代表 and 逻辑的符号。

& 后台工作
单一个& 符号，且放在完整指令列的最后端，即表示将该指令列放入后台中工作。
tar cvfz data.tar.gz data > /dev/null&

\\< ...\\> 单字边界
这组符号在规则表达式中，被定义为\"边界\"的意思。譬如，当我们想找寻 the 这个单字时，如果我们用
grep the FileA
你将会发现，像 there 这类的单字，也会被当成是匹配的单字。因为 the 正巧是 there的一部份。如果我们要必免这种情况，就得加上 \"边界\" 的符号
grep '\\' FileA

+ 加号 (plus)
在运算式中，她用来表示 \"加法\"。
expr 1 + 2 + 3
此外在规则表达式中，用来表示\"很多个\"的前面字元的意思。
# grep '10\\+9' fileB109100910000910000931010009#这个符号在使用时，前面必须加上escape 字元。

- 减号 (dash)
在运算式中，她用来表示 \"减法\"。
expr 10 - 2
此外也是系统指令的选项符号。
ls -expr 10 - 2
在 GNU 指令中，如果单独使用 - 符号，不加任何该加的文件名称时，代表\"标准输入\"的意思。这是 GNU指令的共通选项。譬如下例
tar xpvf -
这里的 - 符号，既代表从标准输入读取资料。
不过，在 cd 指令中则比较特别
cd -
这代表变更工作目录到\"上一次\"工作目录。

% 除法 (Modulo)
在运算式中，用来表示 \"除法\"。
expr 10 % 2
此外，也被运用在关于变量的规则表达式当中的下列
${parameter%word}${parameter%%word}
一个 % 表示最短的 word 匹配，两个表示最长的 word 匹配。

= 等号 (Equals)
常在设定变数时看到的符号。
vara=123echo \" vara = $vara\"
或者像是 PATH 的设定，甚至应用在运算或判断式等此类用途上。

== 等号 (Equals)
常在条件判断式中看到，代表 \"等于\" 的意思。
if [ $vara == $varb ]
...下略

!= 不等于
常在条件判断式中看到，代表 \"不等于\" 的意思。
if [ $vara != $varb ]
...下略

^
这个符号在规则表达式中，代表行的 \"开头\" 位置，在[]中也与\"!\"(叹号)一样表示“非”

输出/输入重导向
> >> < << :> &> 2&> 2<>>& >&2

文件描述符(File Descriptor)，用一个数字（通常为0-9）来表示一个文件。
常用的文件描述符如下：
文件描述符 名称 常用缩写 默认值
0 标准输入 stdin 键盘
1 标准输出 stdout 屏幕
2 标准错误输出 stderr 屏幕
我们在简单地用< 或>时，相当于使用 0< 或 1>（下面会详细介绍）。
* cmd > file
把cmd命令的输出重定向到文件file中。如果file已经存在，则清空原有文件，使用bash的noclobber选项可以防止复盖原有文件。
* cmd >> file
把cmd命令的输出重定向到文件file中，如果file已经存在，则把信息加在原有文件後面。
* cmd < file
使cmd命令从file读入
* cmd << text
从命令行读取输入，直到一个与text相同的行结束。除非使用引号把输入括起来，此模式将对输入内容进行shell变量替换。如果使用<<- ，则会忽略接下来输入行首的tab，结束行也可以是一堆tab再加上一个与text相同的内容，可以参考後面的例子。
* cmd <<< word
把word（而不是文件word）和後面的换行作为输入提供给cmd。
* cmd <> file
以读写模式把文件file重定向到输入，文件file不会被破坏。仅当应用程序利用了这一特性时，它才是有意义的。
* cmd >| file
功能同>，但即便在设置了noclobber时也会复盖file文件，注意用的是|而非一些书中说的!，目前仅在csh中仍沿用>!实现这一功能。
: > filename 把文件\"filename\"截断为0长度.# 如果文件不存在, 那么就创建一个0长度的文件(与'touch'的效果相同).
cmd >&n 把输出送到文件描述符n
cmd m>&n 把输出 到文件符m的信息重定向到文件描述符n
cmd >&- 关闭标准输出
cmd < &n 输入来自文件描述符n
cmd m<&n m来自文件描述各个n
cmd <&- 关闭标准输入
cmd <&n- 移动输入文件描述符n而非复制它。（需要解释）
cmd >&n- 移动输出文件描述符 n而非复制它。（需要解释）
注意： >&实际上复制了文件描述符，这使得cmd > file 2>&1与cmd 2>&1 >file的效果不一样。
\end{lstlisting}
